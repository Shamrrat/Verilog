1.read and write 
module read_write;
reg [7:0]mem[0:15];
reg w;
reg [3:0]address;
reg [7:0]din;
reg [7:0] dout;
always @(*)
begin
	if (w)
    mem[address]=din;  //write
	else
		
		dout=mem[address]; // read

end
initial
begin
w=1'b1;
address=4;
din=8'b10101010;
$display("write=%b address=%d din=%b memory[address]=%b",w,address,din,mem[address]);
#5;
w=1'b0;
address=4;
$display("read =%b address=%d dout=%b memory[address]=%b",w,address,dout,mem[address]);
end
endmodule
//OUTPUT
write=1 address= 4 din=10101010 memory[address]=xxxxxxxx
read =0 address= 4 dout=xxxxxxxx memory[address]=10101010 
output is xxxxxxxx on write because of your combinational read/write block.
writing and immediately printing before the simulator updates the memory properly.


//2.corrected read and write operation
module corrected_read_write;
    reg [7:0] mem [0:15];
    reg w;
    reg [3:0] address;
    reg [7:0] din;
    reg [7:0] dout;
    reg clk;
    initial clk = 0;
    always #1 clk = ~clk;

    // Write on clock edge
    always @(posedge clk)
    begin
        if (w)
            mem[address] <= din;
    end
    // Async read
    always @(*) 
    begin
        if (!w)
            dout = mem[address];
        else
            dout = 8'b0;
    end
    initial begin
        // WRITE
        w = 1'b1;
        address = 4;
        din = 8'b10101010;
        #3; 
        $display("write: w=%b address=%d din=%b mem[%d]=%b",
                   w, address, din,address, mem[address]);
        // READ
        w = 1'b0;
        #1; 
        $display("read:  w=%b address=%d  mem[%d]=%b dout=%b",
                   w, address,address,mem[address],dout);
    end
endmodule
//OUTPUT
write: w=1 address= 4 din=10101010 mem[ 4]=10101010
read:  w=0 address= 4  mem[ 4]=10101010 dout=10101010

