// 1.blocking 
 module blocking;
reg [3:0]a,b;
initial
begin
	a=3;
	b=2;
$monitor("a=%d  b=%d",a,b);
a=b;
b=a;
end 
endmodule

//2.non-blocking
 module non_blocking;
reg [3:0]a,b;
initial
begin
        a=3;
        b=2;
$monitor("a=%d  b=%d",a,b);
a<=b;
b<=a;
end
endmodule 


//3.half adder
module half_adder(input a,b,output s,c);
assign s=a+b;
assign c=a&b;
endmodule

//testbench
module half_adder_tb;
  reg a,b;
  wire s,c;
 half_adder dut(.a(a),.b(b),.s(s),.c(c));
  initial
  begin
   $monitor("time=%0t |  a=%b  |   b=%b | s=%b | c=%b",$time,a,b,s,c);
   $dumpfile(" half_adder_tb.vcd");
   $dumpvars(0, half_adder_tb);
   #10 a=1'b0; b=1'b0;
   #10 a=1'b0; b=1'b1;
   #10 a=1'b1; b=1'b0;
   #10 a=1'b1; b=1'b1;
   #10 a=1'b0; b=1'b0;
 $finish;
  end
endmodule


//4.2to4 decoder using condition operator
module decoder_con(input [1:0]a,output [3:0]y);
assign y=a==2'b00 ? 4'b0001:a==2'b01 ? 4'b0010:a==2'b10 ? 4'b0100:4'b1000;
endmodule

//testbench
module decoder_tb_tb;
  reg [1:0]a;
  wire [3:0]y ;
 decoder_con dut(.a(a),.y(y));
  initial
  begin
   $monitor("time=%0t |   a=%b  |   y=%b ",$time,a,y);
   $dumpfile("decoder_tb_tb.vcd");
   $dumpvars(0,decoder_tb_tb);
   #10 a=2'b00;
   #10 a=2'b10;
   #10 a=2'b01;
   #10 a=2'b11;
   #10
   $finish;
end
endmodule
